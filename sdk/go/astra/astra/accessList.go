// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package astra

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

type AccessList struct {
	pulumi.CustomResourceState

	// List of address requests that should have access to database endpoints.
	Addresses AccessListAddressArrayOutput `pulumi:"addresses"`
	// The ID of the Astra database.
	DatabaseId pulumi.StringOutput `pulumi:"databaseId"`
}

// NewAccessList registers a new resource with the given unique name, arguments, and options.
func NewAccessList(ctx *pulumi.Context,
	name string, args *AccessListArgs, opts ...pulumi.ResourceOption) (*AccessList, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Addresses == nil {
		return nil, errors.New("invalid value for required argument 'Addresses'")
	}
	if args.DatabaseId == nil {
		return nil, errors.New("invalid value for required argument 'DatabaseId'")
	}
	var resource AccessList
	err := ctx.RegisterResource("index:astra/accessList:AccessList", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetAccessList gets an existing AccessList resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetAccessList(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *AccessListState, opts ...pulumi.ResourceOption) (*AccessList, error) {
	var resource AccessList
	err := ctx.ReadResource("index:astra/accessList:AccessList", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering AccessList resources.
type accessListState struct {
	// List of address requests that should have access to database endpoints.
	Addresses []AccessListAddress `pulumi:"addresses"`
	// The ID of the Astra database.
	DatabaseId *string `pulumi:"databaseId"`
}

type AccessListState struct {
	// List of address requests that should have access to database endpoints.
	Addresses AccessListAddressArrayInput
	// The ID of the Astra database.
	DatabaseId pulumi.StringPtrInput
}

func (AccessListState) ElementType() reflect.Type {
	return reflect.TypeOf((*accessListState)(nil)).Elem()
}

type accessListArgs struct {
	// List of address requests that should have access to database endpoints.
	Addresses []AccessListAddress `pulumi:"addresses"`
	// The ID of the Astra database.
	DatabaseId string `pulumi:"databaseId"`
}

// The set of arguments for constructing a AccessList resource.
type AccessListArgs struct {
	// List of address requests that should have access to database endpoints.
	Addresses AccessListAddressArrayInput
	// The ID of the Astra database.
	DatabaseId pulumi.StringInput
}

func (AccessListArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*accessListArgs)(nil)).Elem()
}

type AccessListInput interface {
	pulumi.Input

	ToAccessListOutput() AccessListOutput
	ToAccessListOutputWithContext(ctx context.Context) AccessListOutput
}

func (*AccessList) ElementType() reflect.Type {
	return reflect.TypeOf((**AccessList)(nil)).Elem()
}

func (i *AccessList) ToAccessListOutput() AccessListOutput {
	return i.ToAccessListOutputWithContext(context.Background())
}

func (i *AccessList) ToAccessListOutputWithContext(ctx context.Context) AccessListOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessListOutput)
}

// AccessListArrayInput is an input type that accepts AccessListArray and AccessListArrayOutput values.
// You can construct a concrete instance of `AccessListArrayInput` via:
//
//          AccessListArray{ AccessListArgs{...} }
type AccessListArrayInput interface {
	pulumi.Input

	ToAccessListArrayOutput() AccessListArrayOutput
	ToAccessListArrayOutputWithContext(context.Context) AccessListArrayOutput
}

type AccessListArray []AccessListInput

func (AccessListArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AccessList)(nil)).Elem()
}

func (i AccessListArray) ToAccessListArrayOutput() AccessListArrayOutput {
	return i.ToAccessListArrayOutputWithContext(context.Background())
}

func (i AccessListArray) ToAccessListArrayOutputWithContext(ctx context.Context) AccessListArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessListArrayOutput)
}

// AccessListMapInput is an input type that accepts AccessListMap and AccessListMapOutput values.
// You can construct a concrete instance of `AccessListMapInput` via:
//
//          AccessListMap{ "key": AccessListArgs{...} }
type AccessListMapInput interface {
	pulumi.Input

	ToAccessListMapOutput() AccessListMapOutput
	ToAccessListMapOutputWithContext(context.Context) AccessListMapOutput
}

type AccessListMap map[string]AccessListInput

func (AccessListMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AccessList)(nil)).Elem()
}

func (i AccessListMap) ToAccessListMapOutput() AccessListMapOutput {
	return i.ToAccessListMapOutputWithContext(context.Background())
}

func (i AccessListMap) ToAccessListMapOutputWithContext(ctx context.Context) AccessListMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(AccessListMapOutput)
}

type AccessListOutput struct{ *pulumi.OutputState }

func (AccessListOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**AccessList)(nil)).Elem()
}

func (o AccessListOutput) ToAccessListOutput() AccessListOutput {
	return o
}

func (o AccessListOutput) ToAccessListOutputWithContext(ctx context.Context) AccessListOutput {
	return o
}

type AccessListArrayOutput struct{ *pulumi.OutputState }

func (AccessListArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*AccessList)(nil)).Elem()
}

func (o AccessListArrayOutput) ToAccessListArrayOutput() AccessListArrayOutput {
	return o
}

func (o AccessListArrayOutput) ToAccessListArrayOutputWithContext(ctx context.Context) AccessListArrayOutput {
	return o
}

func (o AccessListArrayOutput) Index(i pulumi.IntInput) AccessListOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *AccessList {
		return vs[0].([]*AccessList)[vs[1].(int)]
	}).(AccessListOutput)
}

type AccessListMapOutput struct{ *pulumi.OutputState }

func (AccessListMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*AccessList)(nil)).Elem()
}

func (o AccessListMapOutput) ToAccessListMapOutput() AccessListMapOutput {
	return o
}

func (o AccessListMapOutput) ToAccessListMapOutputWithContext(ctx context.Context) AccessListMapOutput {
	return o
}

func (o AccessListMapOutput) MapIndex(k pulumi.StringInput) AccessListOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *AccessList {
		return vs[0].(map[string]*AccessList)[vs[1].(string)]
	}).(AccessListOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*AccessListInput)(nil)).Elem(), &AccessList{})
	pulumi.RegisterInputType(reflect.TypeOf((*AccessListArrayInput)(nil)).Elem(), AccessListArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*AccessListMapInput)(nil)).Elem(), AccessListMap{})
	pulumi.RegisterOutputType(AccessListOutput{})
	pulumi.RegisterOutputType(AccessListArrayOutput{})
	pulumi.RegisterOutputType(AccessListMapOutput{})
}
